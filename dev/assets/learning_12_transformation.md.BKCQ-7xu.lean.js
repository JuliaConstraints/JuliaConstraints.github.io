import{_ as o,c as l,a5 as a,j as i,a as t,G as e,B as r,o as p}from"./chunks/framework.CJakPlgM.js";const J=JSON.parse('{"title":"Transformations Layer","description":"","frontmatter":{},"headers":[],"relativePath":"learning/12_transformation.md","filePath":"learning/12_transformation.md","lastUpdated":null}'),h={name:"learning/12_transformation.md"},d={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""};function L(A,s,q,D,X,T){const n=r("Badge");return p(),l("div",null,[s[57]||(s[57]=a('<h1 id="Transformations-Layer" tabindex="-1">Transformations Layer <a class="header-anchor" href="#Transformations-Layer" aria-label="Permalink to &quot;Transformations Layer {#Transformations-Layer}&quot;">​</a></h1><p>Some text to describe the transformation layer within usual ICNs.</p><p>The implementation of the transformation relies heavily on the use of the lazy function (make a ref, open an issue to make <code>@lazy</code> macro in front of each transformation).</p><h2 id="List-of-transformations" tabindex="-1">List of transformations <a class="header-anchor" href="#List-of-transformations" aria-label="Permalink to &quot;List of transformations {#List-of-transformations}&quot;">​</a></h2><p>List the possible parameters and how it affects the transformations.</p><h3 id="non-parametric" tabindex="-1">Non-parametric <a class="header-anchor" href="#non-parametric" aria-label="Permalink to &quot;Non-parametric&quot;">​</a></h3>',6)),i("details",d,[i("summary",null,[s[0]||(s[0]=i("a",{id:"CompositionalNetworks.tr_identity-learning-12_transformation",href:"#CompositionalNetworks.tr_identity-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_identity")],-1)),s[1]||(s[1]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[2]||(s[2]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Identity function. Already defined in Julia as <code>identity</code>, specialized for vectors. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L3-L10" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",k,[i("summary",null,[s[3]||(s[3]=i("a",{id:"CompositionalNetworks.tr_count_eq-learning-12_transformation",href:"#CompositionalNetworks.tr_count_eq-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_eq")],-1)),s[4]||(s[4]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[5]||(s[5]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements equal to <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L16-L23" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",c,[i("summary",null,[s[6]||(s[6]=i("a",{id:"CompositionalNetworks.tr_count_eq_right-learning-12_transformation",href:"#CompositionalNetworks.tr_count_eq_right-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_eq_right")],-1)),s[7]||(s[7]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[8]||(s[8]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements to the right of and equal to <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L26-L33" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",u,[i("summary",null,[s[9]||(s[9]=i("a",{id:"CompositionalNetworks.tr_count_eq_left-learning-12_transformation",href:"#CompositionalNetworks.tr_count_eq_left-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_eq_left")],-1)),s[10]||(s[10]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[11]||(s[11]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements to the left of and equal to <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L36-L43" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",g,[i("summary",null,[s[12]||(s[12]=i("a",{id:"CompositionalNetworks.tr_count_greater-learning-12_transformation",href:"#CompositionalNetworks.tr_count_greater-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_greater")],-1)),s[13]||(s[13]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[14]||(s[14]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_greater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_greater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_greater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements greater than <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L51-L58" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",m,[i("summary",null,[s[15]||(s[15]=i("a",{id:"CompositionalNetworks.tr_count_lesser-learning-12_transformation",href:"#CompositionalNetworks.tr_count_lesser-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_lesser")],-1)),s[16]||(s[16]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[17]||(s[17]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_lesser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_lesser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_lesser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements lesser than <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L61-L68" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",y,[i("summary",null,[s[18]||(s[18]=i("a",{id:"CompositionalNetworks.tr_count_g_left-learning-12_transformation",href:"#CompositionalNetworks.tr_count_g_left-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_g_left")],-1)),s[19]||(s[19]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[20]||(s[20]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_left</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements to the left of and greater than <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L71-L78" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",E,[i("summary",null,[s[21]||(s[21]=i("a",{id:"CompositionalNetworks.tr_count_g_right-learning-12_transformation",href:"#CompositionalNetworks.tr_count_g_right-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_g_right")],-1)),s[22]||(s[22]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[23]||(s[23]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements to the right of and greater than <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L91-L97" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",_,[i("summary",null,[s[24]||(s[24]=i("a",{id:"CompositionalNetworks.tr_count_l_right-learning-12_transformation",href:"#CompositionalNetworks.tr_count_l_right-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_l_right")],-1)),s[25]||(s[25]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[26]||(s[26]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_right</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Count the number of elements to the right of and lesser than <code>x[i]</code>. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L100-L107" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",C,[i("summary",null,[s[27]||(s[27]=i("a",{id:"CompositionalNetworks.tr_contiguous_vars_minus-learning-12_transformation",href:"#CompositionalNetworks.tr_contiguous_vars_minus-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_contiguous_vars_minus")],-1)),s[28]||(s[28]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[29]||(s[29]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the difference <code>x[i] - x[i + 1]</code> if positive, <code>0.0</code> otherwise. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L190-L197" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",b,[i("summary",null,[s[30]||(s[30]=i("a",{id:"CompositionalNetworks.tr_contiguous_vars_minus_rev-learning-12_transformation",href:"#CompositionalNetworks.tr_contiguous_vars_minus_rev-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_contiguous_vars_minus_rev")],-1)),s[31]||(s[31]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[32]||(s[32]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus_rev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus_rev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_contiguous_vars_minus_rev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the difference <code>x[i + 1] - x[i]</code> if positive, <code>0.0</code> otherwise. Extended method to vector with sig <code>(x)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L201-L208" target="_blank" rel="noreferrer">source</a></p>`,3))]),s[58]||(s[58]=i("h3",{id:"Param:-:val",tabindex:"-1"},[t("Param: "),i("code",null,":val"),t(),i("a",{class:"header-anchor",href:"#Param:-:val","aria-label":'Permalink to "Param: `:val` {#Param:-:val}"'},"​")],-1)),i("details",f,[i("summary",null,[s[33]||(s[33]=i("a",{id:"CompositionalNetworks.tr_count_eq_val-learning-12_transformation",href:"#CompositionalNetworks.tr_count_eq_val-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_eq_val")],-1)),s[34]||(s[34]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[35]||(s[35]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_eq_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Count the number of elements equal to <code>x[i] + val</code>. Extended method to vector with sig <code>(x, val)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L116-L123" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",v,[i("summary",null,[s[36]||(s[36]=i("a",{id:"CompositionalNetworks.tr_count_l_val-learning-12_transformation",href:"#CompositionalNetworks.tr_count_l_val-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_l_val")],-1)),s[37]||(s[37]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[38]||(s[38]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_l_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Count the number of elements lesser than <code>x[i] + val</code>. Extended method to vector with sig <code>(x, val)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L126-L133" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",F,[i("summary",null,[s[39]||(s[39]=i("a",{id:"CompositionalNetworks.tr_count_g_val-learning-12_transformation",href:"#CompositionalNetworks.tr_count_g_val-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_g_val")],-1)),s[40]||(s[40]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[41]||(s[41]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_g_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Count the number of elements greater than <code>x[i] + val</code>. Extended method to vector with sig <code>(x, val)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L136-L143" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",j,[i("summary",null,[s[42]||(s[42]=i("a",{id:"CompositionalNetworks.tr_count_bounding_val-learning-12_transformation",href:"#CompositionalNetworks.tr_count_bounding_val-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_count_bounding_val")],-1)),s[43]||(s[43]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[44]||(s[44]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_bounding_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_bounding_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_count_bounding_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Count the number of elements bounded (not strictly) by <code>x[i]</code> and <code>x[i] + val</code>. An extended method to vector with sig <code>(x, val)</code> is generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L151-L158" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",x,[i("summary",null,[s[45]||(s[45]=i("a",{id:"CompositionalNetworks.tr_var_minus_val-learning-12_transformation",href:"#CompositionalNetworks.tr_var_minus_val-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_var_minus_val")],-1)),s[46]||(s[46]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[47]||(s[47]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_var_minus_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_var_minus_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_var_minus_val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Return the difference <code>x[i] - val</code> if positive, <code>0.0</code> otherwise. Extended method to vector with sig <code>(x, val)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L166-L173" target="_blank" rel="noreferrer">source</a></p>`,3))]),i("details",w,[i("summary",null,[s[48]||(s[48]=i("a",{id:"CompositionalNetworks.tr_val_minus_var-learning-12_transformation",href:"#CompositionalNetworks.tr_val_minus_var-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.tr_val_minus_var")],-1)),s[49]||(s[49]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[50]||(s[50]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_val_minus_var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i, x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_val_minus_var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x; val)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tr_val_minus_var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, X</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; val)</span></span></code></pre></div><p>Return the difference <code>val - x[i]</code> if positive, <code>0.0</code> otherwise. Extended method to vector with sig <code>(x, val)</code> are generated. When <code>X</code> is provided, the result is computed without allocations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L176-L183" target="_blank" rel="noreferrer">source</a></p>`,3))]),s[59]||(s[59]=i("h3",{id:"Layer-generation",tabindex:"-1"},[t("Layer generation "),i("a",{class:"header-anchor",href:"#Layer-generation","aria-label":'Permalink to "Layer generation {#Layer-generation}"'},"​")],-1)),i("details",N,[i("summary",null,[s[51]||(s[51]=i("a",{id:"CompositionalNetworks.make_transformations-learning-12_transformation",href:"#CompositionalNetworks.make_transformations-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.make_transformations")],-1)),s[52]||(s[52]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[53]||(s[53]=a(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">make_transformations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(param</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generates a dictionary of transformation functions based on the specified parameterization. This function facilitates the creation of parametric layers for constraint transformations, allowing for flexible and dynamic constraint manipulation according to the needs of different constraint programming models.</p><p><strong>Parameters</strong></p><ul><li><code>param::Symbol</code>: Specifies the type of transformations to generate. It can be <code>:none</code> for basic transformations that do not depend on external parameters, or <code>:val</code> for transformations that operate with respect to a specific value parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>LittleDict{Symbol, Function}</code>: A dictionary mapping transformation names (<code>Symbol</code>) to their corresponding functions (<code>Function</code>). The functions encapsulate various types of transformations, such as counting, comparison, and contiguous value processing.</li></ul><p><strong>Transformation Types</strong></p><ul><li><p>When <code>param</code> is <code>:none</code>, the following transformations are available:</p><ul><li><p><code>:identity</code>: No transformation is applied.</p></li><li><p><code>:count_eq</code>, <code>:count_eq_left</code>, <code>:count_eq_right</code>: Count equalities under different conditions.</p></li><li><p><code>:count_greater</code>, <code>:count_lesser</code>: Count values greater or lesser than a threshold.</p></li><li><p><code>:count_g_left</code>, <code>:count_l_left</code>, <code>:count_g_right</code>, <code>:count_l_right</code>: Count values with greater or lesser comparisons from different directions.</p></li><li><p><code>:contiguous_vals_minus</code>, <code>:contiguous_vals_minus_rev</code>: Process contiguous values with subtraction in normal and reverse order.</p></li></ul></li><li><p>When <code>param</code> is <code>:val</code>, the transformations relate to operations involving a parameter value:</p><ul><li><p><code>:count_eq_param</code>, <code>:count_l_param</code>, <code>:count_g_param</code>: Count equalities or comparisons against a parameter value.</p></li><li><p><code>:count_bounding_param</code>: Count values bounding a parameter value.</p></li><li><p><code>:val_minus_param</code>, <code>:param_minus_val</code>: Subtract a parameter value from values or vice versa.</p></li></ul></li></ul><p>The function delegates to a version that uses <code>Val(param)</code> for dispatch, ensuring compile-time selection of the appropriate transformation set.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get basic transformations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">basic_transforms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> make_transformations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Apply an identity transformation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">identity_result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> basic_transforms[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:identity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">](data)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Get value-based transformations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">val_transforms </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> make_transformations</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Apply a count equal to parameter transformation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count_eq_param_result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val_transforms[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:count_eq_param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">](data, param)</span></span></code></pre></div><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L216-L262" target="_blank" rel="noreferrer">source</a></p>`,12))]),i("details",B,[i("summary",null,[s[54]||(s[54]=i("a",{id:"CompositionalNetworks.transformation_layer-learning-12_transformation",href:"#CompositionalNetworks.transformation_layer-learning-12_transformation"},[i("span",{class:"jlbinding"},"CompositionalNetworks.transformation_layer")],-1)),s[55]||(s[55]=t()),e(n,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[56]||(s[56]=a('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">transformation_layer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(param </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Vector{Symbol}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Generate the layer of transformations functions of the ICN. Iff <code>param</code> value is non empty, also includes all the related parametric transformations.</p><p><a href="https://github.com/JuliaConstraints/CompositionalNetworks.jl/blob/v0.5.9/src/layers/transformation.jl#L298-L301" target="_blank" rel="noreferrer">source</a></p>',3))])])}const O=o(h,[["render",L]]);export{J as __pageData,O as default};
